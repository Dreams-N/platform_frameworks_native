Revision: a7851556c0e3ac6e0efdf37903b0eb59f559010c
Patch-set: 1
File: libs/binder/Parcel.cpp

104:17-104:45
Tue Feb 02 23:11:25 2016 +0000
Author: Mark Salyzyn <1032276@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 9124acf4_5b2ec37e
Bytes: 275
atomic_load_explicit(...memory_order_acquire)

Good citizenship award. Would help reduce the window for multiple threads to be running the following code. a mutex is considered too costly and thus precludes being able to run any of this in a signal handler (nbd ... and ick).

110:0-110:34
Wed Feb 03 20:19:33 2016 +0000
Author: Mark Salyzyn <1032276@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: b121b0e4_57017698
Bytes: 46
This is bad practice, zero will prevent match.

130:4-130:48
Tue Feb 02 23:11:25 2016 +0000
Author: Mark Salyzyn <1032276@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 11f7dc9a_34a2f66d
Bytes: 485
atomic_store_explicit(...memory_order_release) as counter to the above.

In any case, this is dealing with a rare and meaningless corner case of doing this on thread startups. A particularly mean actor could start 1000 threads and thus 1000 attempts to open /dev/ashmem if the first thing they did was a binder acquire.

No one does that :-)

The alternative is to deploy a mutex to stop such behavior in its tracks. After the first call, mutex could cause continuing syscall overhead.

