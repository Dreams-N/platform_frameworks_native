Revision: 00018b3c5254a335340c645a658af6ba3423c72e
Patch-set: 2
File: opengl/tools/glgen/stubs/egl/EGL14cHeader.cpp

17
Tue Nov 11 23:55:12 2014 +0000
Author: Stephen Hines <1010056@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 5a4f777e_f9bed1a4
Bytes: 116
Where are these generated from? Any changes in this CL seem like they are going to get wiped out if/when we refresh.

17
Wed Nov 12 00:20:00 2014 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 5a4f777e_f9bed1a4
UUID: 5a4f777e_b97859ef
Bytes: 131
Nope. This is the source for the auto-generated files in frameworks/base/core/jni. This is copied verbatim into the target files...

File: opengl/tools/glgen/stubs/gles11/glDrawArraysIndirect.cpp

6:53-6:84
Tue Nov 11 08:34:00 2014 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 7ac51b23_97aeaef6
Bytes: 122
I don't understand the comment above and am open for opinions. Maybe this should just be static_cast<jlong>(UINT32_MAX)...

6:53-6:84
Tue Nov 11 14:44:55 2014 +0000
Author: Jesse Hall <1010672@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 7ac51b23_97aeaef6
UUID: 7ac51b23_224a1674
Bytes: 342
The code is trying to check whether 'indirect', a signed 64-bit value, is larger than the maximum 32-bit pointer value. If not, the cast in the call to glDrawArraysIndirect will modify the bits, and the call won't do what the app intended.

What warning are you getting here? Does the warning only happen in 64-bit builds (or only in 32-bit)?

6:53-6:84
Tue Nov 11 17:14:47 2014 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 7ac51b23_224a1674
UUID: 5a4f777e_e74ab11f
Bytes: 167
The warning is a signed-compare warning on 64b, as there UINTPTR_MAX is 64b unsigned.

From your description, the right thing here will be UINT32_MAX. Would you agree?

6:53-6:84
Tue Nov 11 23:55:12 2014 +0000
Author: Stephen Hines <1010056@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 5a4f777e_e74ab11f
UUID: 5a4f777e_19640dbe
Bytes: 172
I think UINT32_MAX is a better value to use here. It is doing exactly that (making sure that you don't have a value that won't fit in 32-bits, but only on 32-bit compiles).

6:53-6:84
Wed Nov 12 00:31:46 2014 +0000
Author: Jesse Hall <1010672@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 5a4f777e_e74ab11f
UUID: 9ab9efac_07ab766c
Bytes: 567
(I thought I added this comment, but apparently not. Anyway, it's not worth arguing about. Feel free to switch to UINT32_MAX).

I don't get it: we cast UINTPTR_MAX to jlong, which is the same type as 'indirect'. The types in that comparison should always match, because the code forces them to.

We want to compare against the maximum pointer value, if pointer is different size than the Java 'indirect' value. Using UINT32_MAX would work but it doesn't express the intent as well. Not a big deal to change it, but (as I said above) I don't understand why we need to.

6:53-6:84
Wed Nov 12 00:39:40 2014 +0000
Author: Stephen Hines <1010056@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 9ab9efac_07ab766c
UUID: 7aaefb66_2f68c964
Bytes: 252
For 64-bit compiles, nothing can be > UINTPTR_MAX, so that it provably false. I think that is the warning that must be firing for Andreas. It is more correct to switch to UINT32_MAX, because that is the only case that you are comparing it for actually.

6:53-6:84
Wed Nov 12 04:09:55 2014 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 7aaefb66_2f68c964
UUID: 3aa8035b_474ad0a6
Bytes: 624
The warning is that indirect is a jlong, which is basically int64_t, whereas UINTPTR_MAX is uint64_t. So you have a signed value on the left and an unsigned value on the right.

I added the cast to ensure the same types. But that cast will have the value -1 on 64bit system, which is not what's expected, at least from what I understand from your explanation.

I am not sure what a "32bit pointer value" is. What is meant by that on a 64bit system?

Replacing UINTPTR_MAX with UINT32_MAX will basically ask whether indirect > 4G (>32bit). I'll wait with the submission until tomorrow in case that is not what is needed here.

6:53-6:84
Wed Nov 12 16:09:53 2014 +0000
Author: Jesse Hall <1010672@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 3aa8035b_474ad0a6
UUID: 3aa8035b_4a7897ee
Bytes: 876
Let's just use UINT32_MAX. Like I said, it's not worth spending time on.

I'm just being pedantic. As written, the code is correct (I believe) regardless of the sizes of pointer and jlong. It's just checking that, if they have different sizes, a jlong value can be cast to void* losslessly. That's why it uses UINTPTR_MAX, because that's the max value of a pointer, which is what it's going to cast to. At that point in the expression we've already established that pointers and jlongs have different size, so it doesn't matter what happens to UINTPTR_MAX when it overflows jlong. Using UINT32_MAX bakes in the assumption that if the size is different, then pointers are 32 bits; using UINTPTR_MAX does not make that assumption about pointer size.

But in practice that assumption is always true, and is going to be true for the foreseeable lifetime of this code. So whatever.

