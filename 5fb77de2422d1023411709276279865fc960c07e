Revision: 5fb77de2422d1023411709276279865fc960c07e
Patch-set: 5
File: libs/binder/PersistableBundle.cpp

60
Tue Dec 01 18:30:57 2015 +0000
Author: Christopher Wiley <1057759@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: db0f1bb0_44ea22ca
Bytes: 448
Woah, you're calling status (which is a method call) twice.  This should definitely look like:

#define RETURN_IF_FAILED(calledOnce)                        \
  {                                                         \
    returnIfFailedStatus = calledOnce;                      \
    if (returnIfFailedStatus) return returnIfFailedStatus;  \
  }

Maybe declare a companion macro:

#define RETURN_IF_FAILED_INIT status_t returnIfFailedStatus = OK;

108
Tue Dec 01 18:30:57 2015 +0000
Author: Christopher Wiley <1057759@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 9b0923b2_d1949669
Bytes: 58
Probably should return the status_t of readFromParcelInner

141
Tue Dec 01 18:30:57 2015 +0000
Author: Christopher Wiley <1057759@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: fbde9f59_7a4ee5bb
Bytes: 623
Unfortunately, I don't think this allows you to overwrite values right?  Doesn't this have to look like:

auto it = mIntMap.find(key);
if (it != mIntMap.end()) {
  it->second = value;
} else {
  mIntMap.emplace_hint(it, key, value);
}

That could probably just become a templated function in an anonymous namespace:


namespace {

template<typename T>
void putValue(const String16& key,
              const T& value,
              std::map<String16, T>* theMap) {
  auto it = theMap->find(key);
  if (it != theMap->end()) {
    it->second = value;
  } else {
    theMap->emplace_hint(it, key, value);
  }
}

}  // namespace

191
Tue Dec 01 18:30:57 2015 +0000
Author: Christopher Wiley <1057759@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: fbde9f59_ba91ed38
Bytes: 53
nit: this should probably be a templated function too

346:9-346:32
Tue Dec 01 18:30:57 2015 +0000
Author: Christopher Wiley <1057759@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 1be45325_004f7613
Bytes: 31
Weird.  Why?  We have |length|?

